import Acorn from "acorn";
import Chalk from "chalk";

import ApplicationTypeEnum from "@src/process/ApplicationTypeEnum";
import BranchConstraint from "./constraints/BranchConstraint";
import CodePosition from "./code_position";
import ConfigReader from "@src/config/user_argument_parsing/Config";
import * as ConstraintFactory from "./constraints/ConstraintFactory"
import countLinesTraverse from "./count_lines";
import {doRegularApply} from "./helper";
import EstreeOperations from "@src/instrumentation/EstreeOperations";
import ExecutionStateCollector from "@src/tester/ExecutionStateCollector";
import {generateInputObject, generateInputString} from "../symbolic_expression/helper";
import {getSymJSHandler} from "@src/tester/solve/util";
import * as GTS from "../tester/global_tester_state";
import IdentifierUpdater from "./IdentifierUpdater";
import Interceptor from "./interceptor/Interceptor";
import {jsPrint} from "../util/io_operations";
import KeyEvent from "../process/events/KeyEvent";
import {ExecutionState, newExecutionState} from "@src/tester/ExecutionState";
import {Logger as Log} from "../util/logging";
import MergingStatesStore from "@src/tester/MergingState";
import MouseClickEvent from "@src/process/events/MouseClickEvent";
import Nothing, {isNothing} from "@src/symbolic_expression/nothing";
import Process from "../process/processes/Process";
import SharedOutput from "../util/output";
import * as SymExpConversion from "../symbolic_expression/convert_symbolic_expressions";
import * as SymTypes from "../symbolic_expression/supported_symbolic_types";
import SocketIOTarget from "@src/process/targets/SocketIOTarget";
import {SymbolicExpression} from "../symbolic_expression/symbolic_expressions";
import SymbolicFunction from "@src/symbolic_expression/symbolic_function"
import SymStore from "@src/tester/SymbolicStore";
import tainter, { dirty, tame, value, wild } from "./tainter";
import {TestRunner} from "@src/tester/test-runners/TestRunner";
import TestTracer from "@src/tester/TestTracer/TestTracer";
import UserAnnotations from "./UserAnnotations";
import SymbolicString from "@src/symbolic_expression/symbolic_string";
import Constraint from "@src/instrumentation/constraints/Constraint";
import {SymbolicScope} from "@src/tester/SymbolicScope.js";
import LineColumnCodePosition from "@src/instrumentation/LineColumnCodePosition.js";


export default class Advice {
    private MOCKED_SOCKET_ON = 0xF0;
    private GENERATE_INPUT_STRING = 0xf1;
    private GENERATE_INPUT_OBJECT = 0xf3;

    protected _factoryInstance: any;
    protected _testRunner: TestRunner;
    protected _identifierUpdater: any;

    public functionsToIntercept: Interceptor;

    protected _ES: EstreeOperations;

    /**
     * An Advice instance is specific to a particular source, and associated aran instance.
     * @param _aran aran instance associated with this advice. Used to access aran.nodes
     * @param _pointcut aran pointcut, used to dynamically weave aran in eval statements
     * @param _testRunner the associated testRunner to send instrumented events to
     * @param _interceptor the Interceptor.
     * @param _argm callback arguments generated by aran-remote. Used to extract the alias.
     * @param _process process being instrumented with this advice
     * @param _global the global namespace object (window for web, global for node)
     */
    constructor(protected _aran: any,
                protected _pointcut: Function,
                aranRemoteCallbackFactoryInstance,
                adviceFactory: any,
                protected _argm: any,
                protected _process: Process,
                protected _global,
                protected testTracer: TestTracer) { 
        this._factoryInstance = aranRemoteCallbackFactoryInstance;
        this._testRunner = this._factoryInstance._testRunner;
        this._identifierUpdater = new IdentifierUpdater();
        this.functionsToIntercept = adviceFactory.createIntercepter(_global, _process, doRegularApply);
        this._ES = new EstreeOperations(_aran);
        const codePosition = new CodePosition(_process.processId, -1);
        this.setExecutionState(newExecutionState(codePosition));
    }

    get getExecutionState() {
        return ExecutionStateCollector.getExecutionState(this._process.processId);
    }
    public setExecutionState(executionState: ExecutionState) {
        ExecutionStateCollector.setExecutionState(this._process.processId, executionState);
    }

    /**
     *
     * @param symbolicCondition
     * @param concreteCondition
     * @private
     */
    private _wrapCondition(symbolicCondition: SymbolicExpression, concreteCondition: any): BranchConstraint {
        const wasTrue: boolean = !!concreteCondition; // Force boolean type conversion
        return new BranchConstraint(this._process.processId, symbolicCondition, wasTrue, this.getExecutionState);
    }

    private _addToVarName($$value: dirty, identifier: string): string {
        const newVarName = (SymTypes.isString($$value.varName)) ?
                           $$value.varName + "." + identifier.toString() :
                           "__anonymous__." + identifier.toString();
        return newVarName;
    }

    private _filterRelevantInputsFromPath(path: Constraint[]) {
        const inputsUsed = GTS.globalTesterState!.getSymbolicInputs();
        var relevantInputsUsed = new Set();

        function filterOutRelevantSymbolicInputs(constraint: BranchConstraint) {
            const symbolic = constraint.symbolic;
            const inputsUsedInConstraint = inputsUsed.filter(function (wrapper) {
                return symbolic.usesValue((value) => value.isSameSymValue(wrapper.input.symbolic));
            });
            relevantInputsUsed = new Set([...relevantInputsUsed, ...inputsUsedInConstraint]);
        }

        path.forEach((constraint: Constraint) => {
            if (constraint.type === "CONSTRAINT") {
                filterOutRelevantSymbolicInputs(constraint as BranchConstraint);
            }
        });
        return relevantInputsUsed;
    }

    private _filterRelevantEvents(path: Constraint[]): Constraint[] {
        return path.filter((constraint) => constraint.type === "TARGET");
    }

    private _printErrorReport(): void {
        const path = GTS.globalTesterState!.getGlobalPathConstraint();
        const relevantInputsUsed = this._filterRelevantInputsFromPath(path);
        const relevantEvents = this._filterRelevantEvents(path);
        if (relevantEvents.length > 0) {
            jsPrint(Chalk.green("Error encountered by assigning the following user events: None"));
        } else {
            relevantInputsUsed.forEach((wrappedInput: any) => {
                jsPrint(Chalk.green("Relevant symbolic input parameters used:"));
                jsPrint(`Symbolic value has input ${wrappedInput.input.base} and source: "${wrappedInput.origin}"`);
            });
        }
        // jsPrint(Chalk.green("Error encountered by triggering the following user events:"));
        // relevantEvents.forEach((event) => {
        //   jsPrint("Advice._printErrorReport, event.symbolic", event);
        //   const processId = (ConfigReader.config.TEST_INDIVIDUAL_PROCESSES) ? 0 : event.symbolic.processIdChosen;
        //   const processName = GTS.globalTesterState!.getProcesses()[processId].alias;
        //   jsPrint(event);
        // }); 
    }

    protected _errorDiscovered(errorMessage: any, serial: number): void {
        const file = this._process.displayName;
        const line = (this._aran.nodes[serial] && this._aran.nodes[serial].loc) ? this._aran.nodes[serial].loc.start.line : "UNKNOWN";
        const column = (this._aran.nodes[serial] && this._aran.nodes[serial].loc) ? this._aran.nodes[serial].loc.start.column : "UNKNOWN";
        const serverOrClient = (this._process.applicationType === ApplicationTypeEnum.NODE) ? "(Server)" : "(Client)";
        jsPrint(Chalk.red(`${serverOrClient}: Tester detected error in file "${file}", at position (${line}:${column})`));
        jsPrint(Chalk.red(errorMessage));
        this._factoryInstance._testRunner.errorDiscovered(this._process, errorMessage);
        SharedOutput.getOutput().errorDiscovered(serial, this._aran.nodes);
        this._printErrorReport();
    }

    private _isATextInputField(object: any): boolean {
        return object instanceof (this._process.global.window.HTMLInputElement) && object.type === "text";
    }

    private _isATextInputFieldValueGet(object, key: string): boolean {
        return key === "value" && this._isATextInputField(object);
    }

    private _isAJQueryTextInputField(object): boolean {
        return this._isJQueryImported() && object.length > 0 && this._isATextInputField(object[0]);
    }

    private _isAJQueryTextInputValInvocation(object, key: string): boolean {
        return key === "val" && this._isAJQueryTextInputField(object);
    }

    private _isJQueryImported(): boolean {
        return this._process.global.window && this._process.global.window.jQuery;
    }

    private _isJQueryEventRegistration($$object, methodName: string): boolean {
        if (methodName === "mousedown" || methodName === "mouseup" || methodName === "click") {
            const object = tainter.cleanAndRelease($$object);
            return this._isJQueryImported() && object instanceof this._process.global.window.jQuery && object.length > 0;
        } else if (methodName === "keydown" || methodName === "keyup" || methodName === "keypress") {
            const object = tainter.cleanAndRelease($$object);
            return this._isJQueryImported() && object instanceof this._process.global.window.jQuery && object.length > 0;
        } else {
            return false;
        }
    }

    private _isAMouseEventCoordinateGet(object, key: string): MouseClickEvent | boolean | undefined {
        if ((key === "clientX" || key === "clientY") && object && object.constructor.name === "MouseEvent") {
            const result = this._process.getMouseEvent(object);
            // TODO if (result === undefined) return false;
            return result;
        } else {
            return false;
        }
    }

    private _isAKeyPressEventGet(object, key: string): KeyEvent | boolean | undefined {
        if (key === "which" || key === "keyCode" || key === "altKey" || key === "ctrlKey" || key === "metaKey") {
            const result = this._process.getKeyboardEvent(object) || (this._isJQueryImported() && object.originalEvent && this._process.getKeyboardEvent(object.originalEvent));
            // TODO if (result === undefined) return false;
            return result;
        } else {
            return false;
        }
    }

    protected _nodeCovered(serial: number): void {
        this._factoryInstance._testRunner.setWasActive();
        this.setExecutionState(this.getExecutionState.updateSerial(serial, this._process.processId));
        if (serial && this._aran.nodes) {
            const aranNode = this._aran.nodes[serial];
            if (aranNode && aranNode.loc) {
                GTS.globalTesterState!.addLineCovered(this._process.processId, aranNode.loc.start.line, this._process.kindOfProcess);
                GTS.globalTesterState!.addLineCovered(this._process.processId, aranNode.loc.end.line, this._process.kindOfProcess);
            }
        }
    }

    private _handleStringInvocation($$value2: dirty, $$function: dirty, $$values: dirty[], serial: number): dirty {
        const $$result = doRegularApply($$function, $$value2, $$values, serial);
        const symbolic = SymExpConversion.convertStringInvocationToSymbolic($$value2, tainter.cleanAndRelease($$function).name, $$values);
        const $$actualResult = tainter.taintAndCapture(tainter.cleanAndRelease($$result), symbolic);

        function printStringInvocation() {
            Log.ADV(Chalk.blue(`[INVOKE] object = ${tainter.cleanAndRelease($$value2)}`));
            Log.ADV(Chalk.blue(`         key = ${tainter.cleanAndRelease($$function).name}`));
            Log.ADV(Chalk.blue(`         $$actualResult.base = ${tainter.cleanAndRelease($$actualResult)}`));
            Log.ADV(Chalk.blue(`         symbolic = ${symbolic}`));
        }

        printStringInvocation();
        return $$actualResult;
    }

    protected _addIdentifierRead(identifier: string, $$value: dirty): dirty {
        const concValue = tainter.cleanAndRelease($$value);
        const symValue = $$value.symbolic;
        const symCopy = symValue.setIdentifier(identifier);
        this._identifierUpdater.addValue(this._process.processId, identifier, $$value);
        const currentEvent = GTS.globalTesterState!.getCurrentEvent();
        if (currentEvent) {
            getSymJSHandler().readWrite.addRead(currentEvent, identifier, symCopy); 
        }
        const $$valueCopy = tainter.taintAndCapture(concValue, symCopy);
        $$valueCopy.varName = identifier;
        return $$valueCopy;
    }

    protected _addIdentifierWritten(identifier: any, concValue: any, symValue: SymbolicExpression): void {
        if (identifier) {
            Log.VRW("Adding identifier write", identifier, "with concrete value", concValue, " and symbolic value", symValue.toString());
            const asString = "" + identifier;
            this._identifierUpdater.addSymValue(this._process.processId, asString, symValue);
            SymStore.writeIdentifier(asString, concValue, symValue);
            const currentEventSequence = GTS.globalTesterState!.getEventSequence();
            getSymJSHandler().readWrite.addWrite(currentEventSequence, asString, symValue);
            if (ConfigReader.config.MERGE_PATHS && ! isNothing(symValue)) {
                const assignmentConstraint = ConstraintFactory.newAssignmentConstraint(this._process.processId, asString, symValue);
                GTS.globalTesterState!.addConstraint(assignmentConstraint);
            }
        }
    }

    protected _isUserParameter(idx: any, serial: number): boolean {
        return Number.isInteger(idx) && this._ES.refersToFunDeclaration(serial);
    }

    protected _isUserDefinedIdentifier(identifier: string): boolean {
        return SymTypes.isString(identifier);
    }

    // Informers //

    // Transformers //
    abrupt($$error: value, serial: number): value {
        this._nodeCovered(serial);
        // this._errorDiscovered(($$error.base !== undefined) ? tainter.cleanAndRelease($$error, serial) : $$error, serial);
        // Log.ADV("Advice.abrupt:", $$error);
        return $$error;
    }

    argument(_value: dirty, idx: number | "length" | "new.target" | "this", serial: number): dirty {
        this._nodeCovered(serial);
        if (idx === "length" || idx === "new.target") {
            return tainter.taint(_value as unknown as tame | wild);
        } else if (typeof(idx) === "number") {
            const node = this._aran.nodes[serial];
            if (node?.type === "FunctionExpression" && node!.params[idx]?.type === "Identifier") {
                const paramName = node!.params[idx].name;
                // jsPrint(`Adding a write constraint for argument ${paramName} with symbolic value ${_value.symbolic}}`);
                this._addIdentifierWritten(paramName, _value.base, _value.symbolic);
            }
            // console.log(`argument with idx ${idx}:`, );
        }
        return _value as dirty;
    }

    builtin(value, name, serial): dirty {
        this._nodeCovered(serial);
        return tainter.taintAndCapture(value);
    }

    closure($closure: Function, serial: number): dirty {
        this._nodeCovered(serial);
        Reflect.setPrototypeOf($closure, tainter.capture(Function.prototype));
        const lexicalEnvironment = SymStore.topStore();
        const tainted = tainter.taint($closure, new SymbolicFunction(lexicalEnvironment, serial));
        // jsPrint("snapshot:", SymStore.makeSnapshot());
        return tainted;
    }

    eval($$value, serial) {
        this._nodeCovered(serial);
        const script = tainter.release(tainter.clean($$value));
        const transformed = this._aran.weave(Acorn.parse(script), this._pointcut, serial);
        return transformed;
    }

    error(value: tame | wild, serial: number): dirty { //HOOK 1
        this._nodeCovered(serial);
        this._errorDiscovered(value, serial);
        return tainter.taintAndCapture(value);
    }

    failure(error: value, serial: number): value {
        this._nodeCovered(serial);
        return error;
    }

    _handlePrimitiveString(primitive, serial) {
        if (primitive.startsWith(UserAnnotations.ERROR_STRING)) {
            this._errorDiscovered(primitive, serial);
        } else if (primitive === UserAnnotations.PAGE_LOADED_STRING) {
            this.functionsToIntercept.pageLoaded();
        } else if (primitive.startsWith(UserAnnotations.DEBUGGING_STRING) || primitive.startsWith(UserAnnotations.VALIDATING_STRING)) {
            Log.ALL(this._process.alias, Chalk.green(`Process ${this._argm.alias} encountered ${primitive}`));
            this.testTracer.testDebugging(primitive);
        } else if (primitive === UserAnnotations.SERVER_FINISHED_STRING) {
            this._factoryInstance._testRunner.serverFinishedSetup();
        } else if (primitive.startsWith(UserAnnotations.UNDEFINED_VARIABLE_STRING)) {
            this._errorDiscovered(primitive, serial);
        }
    }

    primitive(primitive: undefined | null | boolean | number | string, serial: number): dirty {
        this._nodeCovered(serial);
        if (SymTypes.isString(primitive)) {
            this._handlePrimitiveString(primitive, serial);
        }
        const symbolic = SymExpConversion.convertPrimToSymbolic(primitive);
        const $$result = tainter.taintAndCapture(primitive, symbolic);
        return $$result;
    }

    // identifier prefixed with $$ => tuple (dirty value)
    // not prefixed with $$ => just a JS primitive

    read($$produced: dirty, variable: string, serial: number): dirty {
        this._nodeCovered(serial);
        const aranNode = this._aran.nodes[serial];
        if (aranNode.type === "Identifier") {
            const varName = aranNode.name;
            const $$producedCopy = this._addIdentifierRead(varName, $$produced);
            $$produced.varName = varName;
            Log.VRW("Read variable", variable)
            // this._testRunner._processes[this._testRunner._processes.length - 1].readSharedVar(varName) TODO
            this.testTracer.testVariableRead(varName, $$produced);
            return $$producedCopy;
        }
        return $$produced;
    }

    arrival($callee: Function, newTarget: Function, $$thisValue: dirty, argumentsValue, serial: number): void {
        Log.MRG("$callee:", $callee);
        Log.MRG("$$thisValue:", $$thisValue);
        Log.MRG("argumentsValue:", argumentsValue);
        this._nodeCovered(serial);
        const environment = isNothing($$thisValue.symbolic) ? SymStore.makeNewStore() : $$thisValue.symbolic.environment;
        Log.MRG("environment", environment);
        this.setExecutionState(this.getExecutionState.pushFrame(serial, this._process.processId));
        if (ConfigReader.config.MERGE_PATHS) {
          // Log.STO("Arrival: " + serial);
          SymStore.arrive(environment);
          // Log.STO(`Arrival, stack now: [${SymStore._scopes}]`);
        }
        // Log.ADV(`Arrival: ${serial}`, this._aran.nodes[serial]);
    }
  
    protected _addExitScopeConstraintsFor(poppedScopes: SymbolicScope[]): void {
        poppedScopes.forEach((poppedScope) => {
            const variables = poppedScope.getIdentifiers();
            const scopeId = poppedScope.getId;
            const constraint = ConstraintFactory.newExitScopeConstraint(this._process.processId, variables, scopeId);
            GTS.globalTesterState!.addConstraint(constraint);
        });
    }

    leave(serial) {
        this._nodeCovered(serial);
        this.setExecutionState(this.getExecutionState.popFrame());
        if (ConfigReader.config.MERGE_PATHS) {
            // Log.STO("Leave: ", serial);
            // const poppedScopes = SymStore.popScope(serial);
            const poppedScopes: SymbolicScope[] = [];
            this._addExitScopeConstraintsFor(poppedScopes);
            // Log.STO("Popped scope of symbolic store. Variables:", variables, "Current snapshot:");
            poppedScopes.forEach((poppedScope) => {
                Log.STO(`Left scope ${poppedScope.getSerial} with identifiers ${poppedScope.getIdentifiers()}`);
            });
            if (serial === GTS.globalTesterState?.getBranchSerialToEncounter()) {
                GTS.globalTesterState?.resetBranchSerialToEncounter();
                GTS.globalTesterState?.popBranchFrame(serial);
            }
            Log.STO(`Leaving scope`);
            // Log.STO(SymStore._scopes);
        }
    }

    enter(tag: string, labels: [string], variables: [string], serial: number): void {
        this._nodeCovered(serial);
        const userDefinedVariables: string[] = variables.filter(this._isUserDefinedIdentifier);
        if (ConfigReader.config.MERGE_PATHS) {
            // Log.STO("Enter: " + serial);
            const newScope = SymStore.pushScope(serial);
            Log.STO(`Enter, stack now: [${SymStore._topStore()._scopes}]`);
            const constraint = ConstraintFactory.newEnterScopeConstraint(this._process.processId, userDefinedVariables, newScope.getId);
            GTS.globalTesterState!.addConstraint(constraint);
        }
        for (let variable of userDefinedVariables) {
            SymStore.writeIdentifier(variable, void 0, new Nothing());
        }
        // Log.STO("Entering with serial", serial, "and tag", tag, ":", util.inspect(SymStore.topScope(), {depth: 5}));
        Log.STO("Entering with serial", serial, "and tag", tag, ":", SymStore.topScope());
        if (tag === "program") {
            for (let aranNode of this._aran.nodes) {
                if (aranNode.type === "Program") {
                    SharedOutput.getOutput().includeAST(aranNode, this._process.processId);
                    const nrOfLines = countLinesTraverse(aranNode);
                    jsPrint("Total number of lines =", nrOfLines);
                }
            }
        }
    }

    protected _containedInsideValidFunction(serial: number): boolean {
        var functionDeclarationEncountered: boolean = false;
        do {
            const aranNode = this._aran.nodes[serial];
            if (aranNode.type === "FunctionDeclaration") {
                functionDeclarationEncountered = true;
                break;
            }
            serial = aranNode.AranParentSerial;
        } while (serial);
        return functionDeclarationEncountered;
    }

    return($$consumed: value, serial: number): value {
        this._nodeCovered(serial);
        if (ConfigReader.config.MERGE_PATHS) {
            // Log.STO("Return: " + serial);
            const identifiers = SymStore.return();
            const constraint = ConstraintFactory.newExitScopeConstraint(this._process.processId, identifiers, -1);
            GTS.globalTesterState!.addConstraint(constraint);
            // const poppedScopes = SymStore.return();
            // this._addExitScopeConstraintsFor(poppedScopes);
            // poppedScopes.forEach((poppedScope) => {
            //   Log.STO(`Return from scope ${poppedScope.getSerial} with identifiers ${poppedScope.getIdentifiers()}`);
            // })
            // Log.STO(`Return, stack now: [${SymStore._scopes}]`);
        }
        return $$consumed;
    }

    success($$value: dirty, serial: number): any {
        this._nodeCovered(serial);
        this._process.finishedSetup();
        Log.ADV(`PROCESS ${this._process.processId} ADVICE___SUCCESSFUL_END1`);
        return tainter.cleanAndRelease($$value);
    }

    test($$test: dirty, serial: number): any {
        this._nodeCovered(serial);
        const wasTrue: boolean = !!$$test.base; // Force boolean conversion
        const position = new CodePosition(this._process.processId, serial);
        const loc = this._aran.nodes[serial]!.loc.start;
        const pos = new LineColumnCodePosition(loc.line, loc.column, String(this._process.processId));
        SharedOutput.getOutput().tookBranch(position, pos, wasTrue);
        // Filter out irrelevant tests (e.g., the default 0 < 5, 1 < 5 etc.)
        if (! this._ES.userDefinedTest(serial)) {
            return tainter.cleanAndRelease($$test);
        }
        if ($$test && !isNothing($$test.symbolic) && $$test.symbolic !== undefined) {
            const constraint: BranchConstraint = this._wrapCondition($$test.symbolic, $$test.base);
            this._testRunner.receiveSymbolicTestCondition(serial, this._argm.alias, constraint);
            if (ConfigReader.config.MERGE_PATHS && this._ES.userDefinedTest(serial)) {
                Log.MRG(`Advice.Test, try merge: execution state ${this.getExecutionState} and constraint`, constraint.symbolic);
                // Log.ADV("Test advice, node =", this._aran.nodes[serial]);
                const symbolicStoreSnapshot = SymStore.makeSnapshot();
                MergingStatesStore.addMergingState(serial, GTS.globalTesterState!.getBranchSequence(), symbolicStoreSnapshot);
                this._factoryInstance._testRunner.tryMerge(this.getExecutionState);

                const optBranchSerial = this._ES.getBranchFrameSerial(serial, constraint.isTrue);
                if (optBranchSerial !== undefined) {
                    GTS.globalTesterState?.pushBranchFrame(optBranchSerial);
                }
            }
        }
        return tainter.cleanAndRelease($$test);
    }

    throw($$consumed: dirty, serial: number): any {
        this._nodeCovered(serial);
        return tainter.cleanAndRelease($$consumed);
    }

    write($$produced: dirty, variable: string, serial: number): dirty {
        this._nodeCovered(serial);
        Log.VRW("Advice.write of variable", variable);
        if (this._isUserDefinedIdentifier(variable) && this._ES.isUserAssignment(variable, serial)) {
            Log.VRW("Suitable Advice.write of variable", variable);
            this._addIdentifierWritten(variable, $$produced.base, $$produced.symbolic);
            Log.ADV("Wrote value to", variable);
            // const $$producedCopy = tainter.taint(tainter.clean($$produced), symValueCopy);
            // $$producedCopy.varName = variable;
            return $$produced;
        } else {
            return $$produced;
        }
    }

    private _isAStringInvocation(cleanedFunction, $$value2): boolean {
        return $$value2 && SymTypes.isString(tainter.cleanAndRelease($$value2));
    }

    private _isAStringGet(value, key): boolean {
        return SymTypes.isString(value) && (key === "length" || SymTypes.isInt(key));
    }

    private _symbolicStringGet($$string: dirty, $$key: dirty, key: string): SymbolicExpression {
        if (key === "length") {
            return SymExpConversion.convertStringInvocationToSymbolic($$string, "length", []);
        } else if (SymTypes.isInt(key)) {
            return SymExpConversion.convertStringInvocationToSymbolic($$string, "charAt", [$$key]);
        } else {
            return new Nothing();
        }
    }

    _addObjectNullConstraint($$object: dirty, serial: number): void {
        const object = tainter.cleanAndRelease($$object);
        const symbolicTemp = SymExpConversion.convertPrimToSymbolic(null);
        const $$null = tainter.taintAndCapture(null, symbolicTemp);
        const symbolic = SymExpConversion.convertObjectConstraintExpToSymbolic("!==", $$object, $$null);
        var constraint;
        if (object === null) {
          constraint = this._wrapCondition(symbolic, false);
        } else {
          constraint = this._wrapCondition(symbolic, true);
        }
        this._testRunner.receiveSymbolicTestCondition(serial, this._argm.alias, constraint);
        console.log("added null constraint")
      }

    // Combiners //
    public _handleReflectGet($$function: dirty, $$value2: dirty, $$values: dirty[], serial: number): dirty {
        const $$object = $$values[0];
        const $$key = $$values[1];
        const object = tainter.cleanAndRelease($$object);
        const key = tainter.cleanAndRelease($$key);
        var $$result;
        if (ConfigReader.config.TEST_INDIVIDUAL_PROCESSES && key === "__mockedSocket__on") {
            const messageType = tainter.cleanAndRelease($$values[0]);
            return tainter.taintAndCapture(function () {}, this.MOCKED_SOCKET_ON);
        // } else if ($$object.symbolic instanceof SymbolicInputObject || $$object.symbolic instanceof SymbolicInputObjectObjectField) {
        //     //inputObjectField acces (need for adding an "object not null constraint")
        //     this._addObjectNullConstraint($$object, serial);
        //     try {
        //       const $$letsTry = doRegularApply($$function, $$value2, $$values, serial);
        //       if (tainter.cleanAndRelease($$letsTry) === undefined) {
        //         const {concrete, symbolic, objectBoolean} = generateInputObjectField(this._process, $$object.base, $$object.symbolic, key);
        //           if (objectBoolean) {
        //             $$result = tainter.taint(concrete, symbolic);
        //           } else {
        //             $$result = tainter.taintAndCapture(concrete, symbolic);
        //           }
        //       } else {
        //         $$result = $$letsTry;
        //       }
        //     } catch (e) {
        //       Log.ADV(Chalk.magenta("Caught error in _handleReflectGet:" + e));
        //       $$result = tainter.taintAndCapture(undefined, new Nothing());
        //       // this._testRunner._endGlobalTestIteration();
        //     }
        } else if (key === "__generate_input_string___") {
            return tainter.taintAndCapture(function() {}, this.GENERATE_INPUT_STRING);
        } else if (key === "__generate_input_object___") {
            return tainter.taintAndCapture(function() {}, this.GENERATE_INPUT_OBJECT);
        } else if (this._process.isANodeProcess() && key === "emit") {
            $$result = doRegularApply($$function, $$value2, $$values, serial);
            const result = tainter.cleanAndRelease($$result);
            this.functionsToIntercept.addSocketEmitReplacement(result);
        } else if (this._isAStringGet(object, key)) {
            const $$tempResult = doRegularApply($$function, $$value2, $$values, serial);
            const symbolic = this._symbolicStringGet($$object, $$key, key);
            $$result = tainter.taint(tainter.clean($$tempResult), symbolic);
        } else if (this._isAMouseEventCoordinateGet(object, key)) {
            $$result = this._process.handleMouseEventGet($$object, $$key, serial);
        } else if (!this._process.isANodeProcess() && this._isATextInputFieldValueGet(object, key)) {
            console.log("Advice: is a TextInputField.value");
            const optCredential = this._testRunner.optGetCredentialsInformation(object.id);
            if (optCredential !== null) {
                $$result = tainter.taintAndCapture(optCredential, new SymbolicString(optCredential));
            } else {
                const {concrete, symbolic} = generateInputString(this._process);
                console.log("Advice: is a TextInputField.value, with concrete =", concrete, "and symbolic.es =", symbolic.executionState.toString(), "and id =", symbolic.id);
                $$result = tainter.taintAndCapture(concrete, symbolic);
            }
            GTS.globalTesterState!.addSymbolicInput($$result, "Reading value from text inputfield " + object?.toString());
        } else if (this._isAKeyPressEventGet(object, key)) {
            $$result = this._process.handleKeyPressEventGet($$object, $$key, serial);
        } else {
            $$result = doRegularApply($$function, $$value2, $$values, serial);
        }
        const varName = this._addToVarName($$object, key);
        const $$resultRead = this._addIdentifierRead(varName, $$result);
        Log.VRW("Read property", varName)
        this.testTracer.testVariableRead(varName, $$resultRead);
        return $$resultRead;
    }

    public _handleReflectSet($$function: dirty, $$value2: dirty, $$values: dirty[], serial: number): dirty {
        const $$object = $$values[0];
        const $$key = $$values[1];
        const $$valueToSet = $$values[2];
        const object = tainter.cleanAndRelease($$object);
        const key = tainter.cleanAndRelease($$key);
        var $$result = tainter.taintAndCapture(undefined, new Nothing());
        const varName = this._addToVarName($$object, key);
        this._addIdentifierWritten(varName, $$valueToSet.base, $$valueToSet.symbolic);
        Log.VRW("Wrote property", varName)
        // if ($$object.symbolic instanceof SymbolicInputObject) {
        //     this._addObjectNullConstraint($$object, serial)
        //     try {
        //       $$result = doRegularApply($$function, $$value2, $$values, serial);
        //       $$result.varName = this._addToVarName($$object, key);
        //       // this._addIdentifierWritten($$result.varName, tainter.cleanAndRelease($$valueToSet), $$valueToSet.symbolic);
        //     } catch (e) {
        //       Log.ADV(Chalk.magenta("Caught error in _handleReflectSet:" + e));
        //       $$result = tainter.taintAndCapture(undefined, new Nothing());
        //       // this._testRunner._endGlobalTestIteration();
        //     }
        //     return $$result;
        // } else {
            $$result = doRegularApply($$function, $$value2, $$values, serial);
            // $$result.varName = this._addToVarName($$object, key);
            // const symValueCopy = this._addIdentifierWritten($$result.varName, tainter.cleanAndRelease($$valueToSet), $$valueToSet.symbolic);
            // return tainter.taint(tainter.clean($$result), symValueCopy);
            return $$result;
        // }
    }

    apply($$function: dirty, $$value2: dirty, $$values: dirty[], serial: number): dirty {
        this._nodeCovered(serial);
        const cleanedFunction = tainter.cleanAndRelease($$function);
        if (ConfigReader.config.TEST_INDIVIDUAL_PROCESSES && $$function.symbolic === this.MOCKED_SOCKET_ON) {
            const messageType = tainter.cleanAndRelease($$values[0]);
            const target = new SocketIOTarget(this._process.processId, this._process.getTotalNumberOfTargets(), messageType, this._process.getNrOfSocketIOTargets(), serial);
            getSymJSHandler().eventHandlerDiscovered(target, GTS.globalTesterState!.getBranchSequence());
            this.testTracer.testNewEventDiscovered(target);
            Log.ADV(Chalk.blue(`SocketIO event registration: ${messageType}`));
            this._process.socketIOTargetDiscovered(target, $$values[1]);
            return tainter.taintAndCapture(() => undefined, new Nothing());
        } else if ($$function.symbolic === this.GENERATE_INPUT_STRING) {
            const {concrete, symbolic} = generateInputString(this._process);
            const $$result = tainter.taintAndCapture(concrete, symbolic);
            GTS.globalTesterState!.addSymbolicInput($$result, "Reading value from a __generate_input_string___-method invocation");
            return $$result;
        } //apply for INPUT Object
          else if ($$function.symbolic === this.GENERATE_INPUT_OBJECT) {
          const {concrete, symbolic} = generateInputObject(this._process);
          const $$result = tainter.taint(concrete, symbolic); //taint zonder capture
          return $$result;
        } else if (this._isAStringInvocation(cleanedFunction, $$value2)) {
            return this._handleStringInvocation($$value2, $$function, $$values, serial);
        } else if (cleanedFunction === this._process.global.Reflect.get) {
            return this._handleReflectGet($$function, $$value2, $$values, serial);
        } else if (cleanedFunction === this._process.global.Reflect.set) {
            return this._handleReflectSet($$function, $$value2, $$values, serial);
        } else if (this.functionsToIntercept.shouldInterceptFunction($$function)) {
            const replacement = this.functionsToIntercept.getReplacement($$function)
            return replacement($$function, $$value2, $$values, serial); // Intercept function and replace execution
        } else if (cleanedFunction === this._process.global.Object) {
            var $$result = doRegularApply($$function, $$value2, $$values, serial);
            if ((tainter.cleanAndRelease($$result) instanceof String) && $$values.length === 1 && SymTypes.isString(tainter.cleanAndRelease($$values[0])) && (!isNothing($$values[0].symbolic))) {
                $$result = tainter.taintAndCapture(tainter.cleanAndRelease($$result), $$values[0].symbolic);
            }
            return $$result;
        } else {
            this.getExecutionState.callFrom(serial, this._process.processId);
            if (! isNothing($$function.symbolic)) {
                Log.MRG("Calling SymStore.arrive");
                // SymStore.arrive($$function.symbolic.environment);
                Log.MRG("After applying closure", SymStore.topStore());
            }
            return doRegularApply($$function, $$value2, $$values, serial);
        }
    }

    binary(operator: string, $$left: dirty, $$right: dirty, serial: number): dirty {
        //operator = "+" | "<" | ">" | ...
        this._nodeCovered(serial);
        const left = tainter.cleanAndRelease($$left);
        const right = tainter.cleanAndRelease($$right);
        const result = this._aran.reflect.binary(operator, left, right);
        let symbolic;
        if (SymTypes.isString(left) || SymTypes.isString(right)) {
            symbolic = SymExpConversion.convertBinStringExpToSymbolic(operator, $$left, $$right);
        // } else if (SymTypes.isObject(left) || SymTypes.isObject(right)) {
        //     symbolic = SymExpConversion.convertObjectConstraintExpToSymbolic(operator, $$left, $$right);
        } else {
            symbolic = SymExpConversion.convertBinExpToSymbolic(operator, $$left, $$right);
        }
        const $$result = tainter.taintAndCapture(result, symbolic);
        return $$result;
    }

    construct($$value: dirty, $$values: dirty[], serial: number): dirty {
        this._nodeCovered(serial);
        const $$result = Reflect.construct(tainter.clean($$value), $$values);
        return $$result;
    }

    unary(operator: string, $$argument: dirty, serial: number): dirty {
        //operator = "typeof" | "!" | ...
        this._nodeCovered(serial);
        const argument = tainter.cleanAndRelease($$argument);
        const result = this._aran.reflect.unary(operator, argument);
        const symbolic = SymExpConversion.convertUnaryExpToSymbolic(operator, $$argument);
        const $$result = tainter.taintAndCapture(result, symbolic);
        return $$result;
    }
}
